.TH "SnapRAID Backup For Disk Arrays" 1
.SH NAME
snapraid \(hy SnapRAID Backup For Disk Arrays
.SH SYNOPSIS 
snapraid [\(hyc, \(hy\(hyconf CONFIG] [\(hyf, \(hy\(hyfilter PATTERN]
.PD 0
.PP
.PD
	[\(hyZ, \(hy\(hyforce\(hyzero] [\(hyE, \(hy\(hyforce\(hyempty]
.PD 0
.PP
.PD
	[\(hys, \(hy\(hystart BLKSTART] [\(hyt, \(hy\(hycount BLKCOUNT]
.PD 0
.PP
.PD
	[\(hyv, \(hy\(hyverbose]
.PD 0
.PP
.PD
	sync|diff|check|fix
.PD 0
.PP
.PD
.PP
snapraid [\(hyV, \(hy\(hyversion] [\(hyh, \(hy\(hyhelp]
.PD 0
.PP
.PD
.SH DESCRIPTION 
SnapRAID is a backup program for a disk array.
.PP
SnapRAID stores redundancy information in the disk array,
and it allows recovering from up to two disk failures.
.PP
SnapRAID is mainly targeted for a home media center, where you have
a lot of big files that rarely change.
.PP
Beside the ability to recover from disk failures, the other
features of SnapRAID are:
.PD 0
.IP \(bu
You can start using SnapRAID with already filled disks.
.IP \(bu
The disks can have different sizes.
.IP \(bu
You can add more disks at any time.
.IP \(bu
If you accidentally delete some files in a disk, you can
recover them.
.IP \(bu
If more than two disks fail, you lose the data only on the
failed disks. All the data in the other disks is safe.
.IP \(bu
It doesn\(cqt lock\(hyin your data. You can stop using SnapRAID at any
time without the need to reformat or move data.
.IP \(bu
All your data is hashed to ensure data integrity and avoid
silent corruption.
.PD
.PP
The official site of SnapRAID is:
.PP
.RS 4
http://snapraid.sourceforge.net
.PD 0
.PP
.PD
.RE
.SH LIMITATIONS 
SnapRAID is in between a RAID and a Backup program trying to get the best
benefits of them. Although it also has some limitations that you should
consider before using it.
.PP
The main one is that if a disk fails, and you haven\(cqt recently synced,
you may not able to do a complete recover.
More specifically, you may be unable to recover up to the size of the
amount of the changed or deleted files, from the last sync operation.
This happens even if the files changed or deleted are not in the
failed disk.
New added files don\(cqt prevent the recovering of the already existing
files. You may only lose the just added files, if they are on the failed
disk.
.PP
This is the reason because SnapRAID is better suited for data that
rarely change.
.PP
Other limitations are:
.PD 0
.IP \(bu
You have different file\(hysystems for each disk.
Using a RAID you have only a big file\(hysystem.
.IP \(bu
It doesn\(cqt stripe data.
With RAID you get a speed boost with striping.
.IP \(bu
It doesn\(cqt support real\(hytime recovery.
With RAID you do not have to stop working when a disk fails.
.IP \(bu
It\(cqs able to recover damages only from up to two disks.
With a Backup you are able to recover from a complete
failure of the whole disk array.
.IP \(bu
Only file data, time and symlinks are saved. Permissions,
extended attributes and hard\(hylinks are not saved.
.PD
.SH GETTING STARTED 
To use SnapRAID you need first select one disk of your disk array
to dedicate at the \(a"parity\(a" information. With parity you will be able
to recover from a single disk failure, like RAID5.
.PP
If you want to recover from two disk failures, like RAID6, you must
reserve another disk for the \(a"q\(hyparity\(a" information.
.PP
For the parity disks, you have to pick the biggest disks in the array,
as the redundancy information may grow in size as the biggest data
disk in the array.
.PP
These disks will be dedicated to store the \(a"parity\(a" and \(a"q\(hyparity\(a"
files.
You should not store other data on them, with the exception of
a copy the \(a"content\(a" file, that contains the list of all the files
stored in your array with all the checksums to verify their integrity.
.PP
For example, suppose that you are interested only at one parity level
of protection, and that your disks are present in:
.PP
.RS 4
/mnt/diskpar <\(hy selected disk for parity
.PD 0
.PP
.PD
/mnt/disk1 <\(hy first disk to backup
.PD 0
.PP
.PD
/mnt/disk2  <\(hy second disk to backup
.PD 0
.PP
.PD
/mnt/disk3 <\(hy third disk to backup
.PD 0
.PP
.PD
.RE
.PP
you have to create the configuration file /etc/snapraid.conf with
the following options:
.PP
.RS 4
parity /mnt/diskpar/parity
.PD 0
.PP
.PD
content /mnt/diskpar/content
.PD 0
.PP
.PD
disk d1 /mnt/disk1/
.PD 0
.PP
.PD
disk d2 /mnt/disk2/
.PD 0
.PP
.PD
disk d3 /mnt/disk3/
.PD 0
.PP
.PD
.RE
.PP
If you are in Windows, you should use drive letters and backslash
instead of slash:
.PP
.RS 4
parity E:\(rspar\(rsparity
.PD 0
.PP
.PD
content E:\(rspar\(rscontent
.PD 0
.PP
.PD
disk d1 F:\(rsarray\(rs
.PD 0
.PP
.PD
disk d2 G:\(rsarray\(rs
.PD 0
.PP
.PD
disk d3 H:\(rsarray\(rs
.PD 0
.PP
.PD
.RE
.PP
At this point you are ready to start the \(a"sync\(a" command to build the
redundancy information.
.PP
.RS 4
snapraid sync
.PD 0
.PP
.PD
.RE
.PP
This process may take some hours the first time, depending on the size
of the data already present in the disks. If the disks are empty
the process is immediate.
.PP
You can stop it at any time pressing Ctrl+C, and at the next run it
will start where interrupted.
.PP
When this command completes, your data is SAFE.
.PP
At this point you can start using your array as you like, and periodically
update the redundancy information running the \(a"sync\(a" command.
.PP
To check the integrity of your data you can use the \(a"check\(a" command:
.PP
.RS 4
snapraid check
.PD 0
.PP
.PD
.RE
.PP
If will read all your data, to check if it\(cqs correct.
.PP
If an error is found, you can use the \(a"fix\(a" command to fix it.
.PP
.RS 4
snapraid fix
.PD 0
.PP
.PD
.RE
.PP
Note that the fix command will revert your data at the state of the
last \(a"sync\(a" command executed. It works like a snapshot was taken
in \(a"sync\(a".
.PP
In this regard snapraid is more like a backup program than a RAID
system. For example, you can use it to recover from an accidentally
deleted directory, simply running the fix command like.
.PP
.RS 4
snapraid fix \(hyf JUST_DELETED_DIR/
.PD 0
.PP
.PD
.RE
.SH COMMANDS 
SnapRAID provides four simple commands that allow to:
.PD 0
.IP \(bu
Make a backup/snapshot \(hy> \(a"sync\(a"
.IP \(bu
See the files changed from the previous sync \(hy> \(a"diff\(a"
.IP \(bu
Check for integrity \(hy> \(a"check\(a"
.IP \(bu
Restore the last backup/snapshot \(hy> \(a"fix\(a".
.PD
.PP
Take care that the commands have be written in lower case.
.TP
.B sync
Updates the redundancy information. All the modified files
in the disk array are read, and the redundancy data is
recomputed.
Files are identified by inode and checked by time and size,
meaning that you can move them on the disk without triggering
any redundancy recomputation.
You can stop this process at any time pressing Ctrl+C,
without losing the work already done.
The \(a"content\(a", \(a"parity\(a" and \(a"q\(hyparity\(a" files are modified if necessary.
The files in the array are NOT modified.
.TP
.B diff
Lists all the files modified from the last \(a"sync\(a" command that
needs to recompute their redundancy data.
Nothing is modified.
.TP
.B check
Checks all the files and the redundancy data.
All the files are hashed and compared with the snapshot saved
in the previous \(a"sync\(a" command.
Files are identified by path, and checked by content.
Nothing is modified.
.TP
.B fix
Checks and fix all the files. It\(cqs like \(a"check\(a" but it
also tries to fix problems reverting the state of the
disk array at the previous \(a"sync\(a" command.
After a successful \(a"fix\(a", you should also run a \(a"sync\(a"
command to update the new state of the files.
The \(a"content\(a" file is NOT modified.
The \(a"parity\(a" and \(a"q\(hyparity\(a" files are modified if necessary.
The files in the array are modified if necessary.
.SH OPTIONS 
SnapRAID provides the following options:
.TP
.B \(hyc, \(hy\(hyconf CONFIG
Selects the configuration file. If not specified is assumed
the file \(cq/etc/snapraid.conf\(cq in Unix, and \(cqsnapraid.conf\(cq
in Windows.
.TP
.B \(hyf, \(hy\(hyfilter PATTERN
Filters the files to operate on with the \(a"check\(a" and \(a"fix\(a"
commands. This option is ignored with the \(a"sync\(a" command.
See the PATTERN section for more details in the
pattern specifications.
This option can be used many times.
In Unix, ensure to quote globbing chars if used.
.TP
.B \(hyZ, \(hy\(hyforce\(hyzero
Forces the insecure operation of syncing a file with zero
size that before was not empty.
If SnapRAID detects such condition, it stops proceeding
unless you specify this option.
This allows to easily detect when after a system crash,
some accessed files were zeroed.
.TP
.B \(hyE, \(hy\(hyforce\(hyempty
Forces the insecure operation of syncing a disk with all
the original files missing.
If SnapRAID detects that all the files originally present
int the disk are missing or overwritten, it stops proceeding
unless you specify this option.
This allows to easily detect when a data file\(hysystem is not
mounted.
.TP
.B \(hys, \(hy\(hystart BLKSTART
Starts the processing from the specified
block number. It could be useful to easy retry to check
or fix some specific block, in case of a damaged disk.
.TP
.B \(hyt, \(hy\(hycount BLKCOUNT
Process only the specified number of blocks.
It\(cqs present mainly for advanced manual recovering.
.TP
.B \(hyv, \(hy\(hyverbose
Prints more information in the processing.
.TP
.B \(hyh, \(hy\(hyhelp
Prints a short help screen.
.TP
.B \(hyV, \(hy\(hyversion
Prints the program version.
.SH CONFIGURATION 
SnapRAID requires a configuration file to know where your disk array
is located, and where storing the redundancy information.
.PP
This configuration file is located in /etc/snapraid.conf in Unix or
in the execution directory in Windows.
.PP
It should contain the following options (case sensitive):
.TP
.B parity FILE
Defines the file to use to store the parity information.
The parity enables the protection from a single disk
failure, like RAID5.
It must be placed in a disk dedicated for this purpose with
as much free space as the biggest disk in the array.
Leaving the parity disk reserved for only this file ensures that
it doesn\(cqt get fragmented, improving the performance.
This option is mandatory and it can be used only one time.
.TP
.B q\(hyparity FILE
Defines the file to use to store the q\(hyparity information.
If present, the q\(hyparity enables the protection from two disk
failures, like RAID6.
It must be placed in a disk dedicated for this purpose with
as much free space as the biggest disk in the array.
Leaving the q\(hyparity disk reserved for only this file ensures that
it doesn\(cqt get fragmented, improving the performance.
This option is optional and it can be used only one time.
.TP
.B content FILE
Defines the file to use to store the list and checksums of all the
files present in your disk array.
It can be placed in the same disk of the parity and q\(hyparity files,
but NOT in a data disk of the array.
This option is mandatory and it can be used more time to save
more copies of the same files.
It\(cqs suggested to store at least one copy for each parity disk.
One more doesn\(cqt hurt, just in case you lose all the parity disks,
and you want to be still able to check the data integrity.
.TP
.B disk NAME DIR
Defines the name and the mount point of the disks of the array.
NAME is used to identify the disk, and it must be unique.
DIR is the mount point of the disk in the filesystem.
You can change the mount point as you like, as long you
keep the NAME fixed.
The specification order is also important, if you change it,
you will invalidate the q\(hyparity file.
You should use one option for each disk of the array.
.TP
.B exclude PATTERN
.TP
.B include PATTERN
Defines the file or directory patterns to exclude and include
in the sync process.
All the patterns are processed in the specified order.
If the first pattern that matches is an \(a"exclude\(a" one, the file
is excluded. If it\(cqs an \(a"include\(a" one the file is included.
If no pattern matches, the file is excluded if the last pattern
is an \(a"include\(a", or included if the last pattern is an \(a"exclude\(a".
See the PATTERN section for more details in the
pattern specifications.
This option can be used many times.
.TP
.B block_size SIZE_IN_KIBIBYTES
Defines the basic block size in kibi bytes of the redundancy
blocks. Where one kibi bytes is 1024 bytes.
The default is 256 and it should work for most conditions.
You could increase this value if you do not have enough RAM
memory to run SnapRAID.
SnapRAID requires about TS*24/BS bytes of RAM memory.
Where TS is the total size in bytes of your disk array,
and BS is the block size in bytes.
.PP
.RS 4
For example with 6 disk of 2 TiB and a block size of 256 KiB
(1 KiB = 1024 Bytes) you have:
.RE
.PP
.RS 4
RAM = (6 * 2 * 2^40) * 24 / (256 * 2^10) = 1.1 GiB
.PD 0
.PP
.PD
.RE
.PP
.RS 4
You could instead decrease this value if you have a lot of
small files in the disk array. For each file, even if of few
bytes, a whole block is always allocated, so you may have a lot
of unused space.
As approximation, you can assume that half of the block size is
wasted for each file.
.RE
.PP
.RS 4
For example, with 10000 files and a 256 KiB block size, you are
going to waste 1.2 GiB.
.RE
.PP
An example of a typical configuration for Unix is:
.PP
.RS 4
parity /mnt/diskpar/parity
.PD 0
.PP
.PD
content /mnt/diskpar/content
.PD 0
.PP
.PD
content /var/snapraid/content
.PD 0
.PP
.PD
disk d1 /mnt/disk1/
.PD 0
.PP
.PD
disk d2 /mnt/disk2/
.PD 0
.PP
.PD
disk d3 /mnt/disk3/
.PD 0
.PP
.PD
exclude *.bak
.PD 0
.PP
.PD
exclude /lost+found/
.PD 0
.PP
.PD
exclude /tmp/
.PD 0
.PP
.PD
.RE
.PP
An example of a typical configuration for Windows is:
.PP
.RS 4
parity E:\(rspar\(rsparity
.PD 0
.PP
.PD
content E:\(rspar\(rscontent
.PD 0
.PP
.PD
content C:\(rssnapraid\(rscontent
.PD 0
.PP
.PD
disk d1 G:\(rsarray\(rs
.PD 0
.PP
.PD
disk d2 H:\(rsarray\(rs
.PD 0
.PP
.PD
disk d3 I:\(rsarray\(rs
.PD 0
.PP
.PD
exclude *.bak
.PD 0
.PP
.PD
exclude Thumbs.db
.PD 0
.PP
.PD
exclude \(rs$RECYCLE.BIN\(rs
.PD 0
.PP
.PD
exclude \(rsSystem Volume Information\(rs
.PD 0
.PP
.PD
.RE
.SH PATTERN 
Patterns are used to select a subset of files to exclude or include in
the process.
.PP
There are four different types of patterns:
.TP
.B FILE
Selects any file named as FILE. You can use any globbing
character like * and ?.
This pattern is applied only to files and not to directories.
.TP
.B DIR/
Selects any directory named DIR. You can use any globbing
character like * and ?.
This pattern is applied only to directories and not to files.
.TP
.B /PATH/FILE
Selects the exact specified file path. You can use any
globbing character like * and ? but they never matches a
directory slash.
This pattern is applied only to files and not to directories.
.TP
.B /PATH/DIR/
Selects the exact specified directory path. You can use any
globbing character like * and ? but they never matches a
directory slash.
This pattern is applied only to directories and not to files.
.PP
In Windows you can freely use the backslash \(rs instead of the forward slash /.
.PP
In the configuration file, you can use different strategies to filter
the files to process.
The simplest one is to only use \(a"exclude\(a" rules to remove all the
files and directories you do not want to process. For example:
.PP
.RS 4
# Excludes any file named \(a"*.bak\(a"
.PD 0
.PP
.PD
exclude *.bak
.PD 0
.PP
.PD
# Excludes the root directory \(a"/lost+found\(a"
.PD 0
.PP
.PD
exclude /lost+found/
.PD 0
.PP
.PD
# Excludes any sub\(hydirectory named \(a"tmp\(a"
.PD 0
.PP
.PD
exclude tmp/
.PD 0
.PP
.PD
.RE
.PP
The opposite way is to define only the file you want to process, using
only \(a"include\(a" rules. For example:
.PP
.RS 4
# Includes only some directories
.PD 0
.PP
.PD
include /movies/
.PD 0
.PP
.PD
include /musics/
.PD 0
.PP
.PD
include /pictures/
.PD 0
.PP
.PD
.RE
.PP
The final way, is to mix \(a"exclude\(a" and \(a"include\(a" rules. In this case take
care that the order of rules is important. Previous rules have the
precedence over the later ones.
To get things simpler you can first have all the \(a"exclude\(a" rules and then
all the \(a"include\(a" ones. For example:
.PP
.RS 4
# Excludes any file named \(a"*.bak\(a"
.PD 0
.PP
.PD
exclude *.bak
.PD 0
.PP
.PD
# Excludes any sub\(hydirectory named \(a"tmp\(a"
.PD 0
.PP
.PD
exclude tmp/
.PD 0
.PP
.PD
# Includes only some directories
.PD 0
.PP
.PD
include /movies/
.PD 0
.PP
.PD
include /musics/
.PD 0
.PP
.PD
include /pictures/
.PD 0
.PP
.PD
.RE
.PP
On the command line, using the \(hyf option, you can only use \(a"include\(a"
patterns. For example:
.PP
.RS 4
# Checks only the .mp3 files.
.PD 0
.PP
.PD
# Note the \(a"\(a" use to avoid globbing expansion by the shell in Unix.
.PD 0
.PP
.PD
snapraid \(hyf \(a"*.mp3\(a" check
.PD 0
.PP
.PD
.RE
.PP
In Unix, when using globbing chars in the command line, you have to quote them.
Otherwise the shell will try to expand them.
.SH CONTENT 
SnapRAID stores the list and checksums of your files in the content file.
.PP
It\(cqs a text file, listing all the files present in your disk array,
with all the checksums to verify their integrity.
.PP
You do not need to understand its format, but it\(cqs described here
for documentation.
.PP
This file is read and written by the \(a"sync\(a" command, and only read by
\(a"fix\(a" and \(a"check\(a".
.TP
.B blk_size SIZE
Defines the size of the block in bytes. It must match the size
defined in the configuration file.
.TP
.B checksum CHECKSUM
Defines the checksum kind used. It can be \(a"md5\(a" or \(a"murmur3\(a".
.TP
.B file DISK SIZE TIME INODE PATH
Defines a file in the specified DISK.
The INODE number is used to identify the file in the \(a"sync\(a"
command, allowing to rename or move the file in disk without
the need to recompute the parity for it.
The SIZE and TIME information are used to identify if the file
changed from the last \(a"sync\(a" command, and if there is the need
to recompute the parity.
The PATH information is used in the \(a"check\(a" and \(a"fix\(a" commands
to identify the file.
.TP
.B blk BLOCK HASH
Defines the ordered parity block list used by the last defined file.
BLOCK is the block position in the \(a"parity\(a" file.
0 for the first block, 1 for the second one and so on.
HASH is the hash of the block. In the last block of the file,
the HASH is the hash of only the used part of the block.
.TP
.B inv BLOCK [HASH]
Like \(a"blk\(a", but inform that the parity of this block is invalid.
The HASH may be missing if not yet computed.
This field is used only when you interrupt manually the \(a"sync\(a"
command.
.SH PARITY 
SnapRAID stores the redundancy information of your array in the parity
and q\(hyparity files.
.PP
They are binary files, containing the computed redundancy of all the
blocks defined in the \(a"content\(a" file.
.PP
You do not need to understand its format, but it\(cqs described here
for documentation.
.PP
These files are read and written by the \(a"sync\(a" and \(a"fix\(a" commands, and
only read by \(a"check\(a".
.PP
For all the blocks at a given position, the parity and the q\(hyparity
are computed as specified in:
.PP
.RS 4
http://kernel.org/pub/linux/kernel/people/hpa/raid6.pdf
.PD 0
.PP
.PD
.RE
.PP
When a file block is shorter than the default block size, for example
because it\(cqs the last block of a file, it\(cqs assumed as filled with 0
at the end.
.SH ENCODING 
SnapRAID in Unix ignores any encoding. It simply read and stores the
file names with the same encoding used by the filesystem.
.PP
In Windows all the names read from the filesystem are converted and
processed in the UTF\(hy8 format.
.PP
To have the file names printed correctly you have to set the Windows
console in the UTF\(hy8 mode, with the command \(a"chcp 65001\(a", and use
a TrueType font like \(a"Lucida Console\(a" for the console font.
Note that it has effect only on the printed file names, if you
redirect the console output to a file, the resulting file is always
in the UTF\(hy8 format.
.SH COPYRIGHT 
This file is Copyright (C) 2011 Andrea Mazzoleni
.SH SEE ALSO 
rsync(1)
